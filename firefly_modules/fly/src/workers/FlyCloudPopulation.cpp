// Copyright 2017 <CÃ©lian Garcia>

#include "fly_module/workers/FlyCloudPopulation.hpp"

namespace firefly {
    namespace fly_module {
        const std::vector<ProcessActionType> FlyCloudPopulation::VALID_ACTION_TYPES = {
                ProcessActionType::START,
                ProcessActionType::STOP,
                ProcessActionType::COLLECT
        };
        const std::string FlyCloudPopulation::DATABASE_NAME = "fcloudpopulation";

        /**
         * - Initiate database connection;
         * - Initiate the cloud model with database manager;
         * - Insert cloud entry in the database;
         * - Run compute thread which put entries in queue;
         * - Run populate thread which move entries from queue to database.
         * @param pool
         * @return id generated by the database.
         */
        int FlyCloudPopulation::start(ThreadPool *pool) {

            DatabaseManager db_manager(DATABASE_NAME);
            Cloud3DModel cloud_model(&db_manager);
            int cloud_id = cloud_model.insertCloud(Cloud3DBean());

            auto *operations = new ConcurrentOperationQueue;

            pool->enqueue([operations] {
                run_compute_thread(operations);
            });

            pool->enqueue([cloud_id, operations] {
                run_populate_thread(cloud_id, operations);
            });

            return cloud_id;
        }

        /**
         * Awaiting for implementation
         */
        void FlyCloudPopulation::stop() {
            throw FireflyException(HtmlStatusCode::NOT_IMPLEMENTED, "Stop action not yet implemented");
        }

        /**
         * Collect operations from database. We only collect the operations from the last time we collect.
         * @param cloud_id the id of the cloud we're collecting.
         * @param client_last_op index of the last operation that we performed.
         * @return operations performed from the last collect.
         */
        std::vector<Operation> FlyCloudPopulation::collect(int cloud_id, int client_last_op) {
            DatabaseManager db_manager(DATABASE_NAME);
            Point3DModel point_model(&db_manager);
            std::vector<Point3DBean> points = point_model.getPointListByCloudId(cloud_id);
            return computeOperationsFromPoints(points, client_last_op);
        }

        void FlyCloudPopulation::run_compute_thread(ConcurrentOperationQueue *operationQueue) {
            for (int i = 0; i < 10; ++i) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::REMOVE, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
            }
            operationQueue->enqueue(Operation::buildEndOperation());
        }

        void FlyCloudPopulation::run_populate_thread(int cloud_id, ConcurrentOperationQueue *queue) {
            std::cout
                    << "Thread starts for the cloud id : " << cloud_id
                    << std::endl;

            // Initialize connection, cloud model, and point model
            DatabaseManager db_manager(DATABASE_NAME);
            Cloud3DModel cloud_model(&db_manager);
            Point3DModel point_model(&db_manager);
            Cloud3DBean cloud = cloud_model.getCloudById(cloud_id);

            // Update the cloud state to populating
            cloud_model.updateCloudState(&cloud, Cloud3DBean::POPULATING_STATE);

            Operation operation = queue->dequeue();
            while (!operation.isEndOperation()) {
                point_model.insertOperation(operation, cloud_id);
                operation = queue->dequeue();
            }

            cloud_model.updateCloudState(&cloud, Cloud3DBean::FINISHED_STATE);

            std::cout
                    << "Thread have finished the work for the cloud_id : " << cloud_id
                    << std::endl;
        }

        std::vector<Operation>
        FlyCloudPopulation::computeOperationsFromPoints(const std::vector<Point3DBean> &points, int last_operation) {
            std::vector<Operation> operations;
            for (auto it = points.begin(); it < points.end(); it++) {
                Operation operation = computeOperationFromPoint(*it, last_operation);
                if (!operation.isNoneOperation() && !operation.isEndOperation()) {
                    operations.push_back(operation);
                }

            }
            return operations;
        }

        /**
         * TODO: remake it using TDD
         * @param point
         * @param last_operation
         * @return
         */
        Operation FlyCloudPopulation::computeOperationFromPoint(const Point3DBean &point, int last_operation) {
            std::vector<int> op_indices = point.getOperationsIds();
            int point_last_op = op_indices.back();
            if (point_last_op <= last_operation) {
                return Operation::buildNoneOperation();
            }
            unsigned long long int i1 = op_indices.size() - 1;
            int i2 = 0;
            for (unsigned int i = 0; i < op_indices.size(); i++) {
                if (op_indices[i] <= last_operation)
                    i2 = i;
                else
                    break;
            }

            if ((i1 - i2) % 2 == 0 && i2 % 2 == 0) {
                return Operation(OperationType::ADD, point.getValue());
            }
             if ((i1 + i2) % 2 == 1 && i2 % 2 == 1) {
                 return Operation(OperationType::REMOVE, point.getValue());
             }

            return Operation::buildNoneOperation();
        }
    }
}