// Copyright 2017 <CÃ©lian Garcia>

#include <fly_module/workers/FlyCloudPopulation.hpp>
#include <fly_module/workers/CloudContainerImpl.hpp>

namespace firefly {
namespace fly_module {

const char *FlyCloudPopulation::DATABASE_NAME = "firefly_hive";

/**
 * - Initiate database connection;
 * - Initiate the cloud model with database manager;
 * - Insert cloud entry in the database;
 * - Run compute thread which put entries in queue;
 * - Run populate thread which move entries from queue to database.
 * @param pool
 * @return id generated by the database.
 */
int FlyCloudPopulation::start(int task_id, ThreadPool *pool, ProcessingType type) noexcept(false) {
    // Move task to STARTED state
    DatabaseManager db_manager(DATABASE_NAME);
    TaskModel task_model(&db_manager);
    task_model.updateTaskStateById(task_id, Task::STARTED);

    auto *operations = new ConcurrentOperationQueue;
    pool->enqueue([operations, type] {
        run_compute_thread(operations, type);
    });

    pool->enqueue([task_id, operations] {
        run_populate_thread(task_id, operations);
    });

    return task_id;
}

/**
 * Awaiting for implementation
 */
void FlyCloudPopulation::stop() {
    throw FireflyException(HtmlStatusCode::NOT_IMPLEMENTED, "Stop action not yet implemented");
}

/**
 * Data Producer : <br>
 * Produce all 3D points for consumer.
 * @param queue Channel where we write operations we create. Red by consumer.
 */
void FlyCloudPopulation::run_compute_thread(ConcurrentOperationQueue *queue, ProcessingType type) {
    CloudContainerImpl *container = new CloudContainerImpl(queue);
    fly::CloudFiller<CloudContainerImpl> filler(container);
    if (type.getAliases()[0] == "P3D") {
        filler.random_filling(20, -10, 10);
    } else if (type.getAliases()[0] == "P3Dr") {
        filler.random_filling(20, -10, 10);
    } else if (type.getAliases()[0] == "P3Dd") {
        filler.diamond_filling(5, 4, 5, 4, 3, {0, 0, 0});
    }
    queue->endQueue();
    delete container;
}

/**
 * Data Consumer: <br>
 * Consumes all data given by producer storing them in the database.
 * @param task_id Still necessary to know where to store operations in database.
 * @param queue Channel where we read operations to save in database. Written by producer.
 */
void FlyCloudPopulation::run_populate_thread(int task_id, ConcurrentOperationQueue *queue) {
    std::cout << "Thread starts for the task id : " << task_id << std::endl;

    // Trying to get task from database
    DatabaseManager db_manager(DATABASE_NAME);
    TaskModel task_model(&db_manager);
    OperationModel operation_model(&db_manager);

    // Save all operations in base
    while (!queue->isEmptyAndEnded()) {
        Operation operation = queue->dequeue();
        operation_model.insertOperation(operation, task_id);
    }

    // Move task to FINISHED state
    task_model.updateTaskStateById(task_id, Task::FINISHED);

    std::cout << "Thread have finished the work for the task of id : " << task_id << std::endl;
}

}  // namespace fly_module
}  // namespace firefly
