// Copyright 2017 <CÃ©lian Garcia>

#include <firefly/core/model/OperationModel.hpp>
#include "fly_module/workers/FlyCloudPopulation.hpp"

namespace firefly {
namespace fly_module {

const std::string FlyCloudPopulation::DATABASE_NAME = "firefly_hive";

/**
 * - Initiate database connection;
 * - Initiate the cloud model with database manager;
 * - Insert cloud entry in the database;
 * - Run compute thread which put entries in queue;
 * - Run populate thread which move entries from queue to database.
 * @param pool
 * @return id generated by the database.
 */
int FlyCloudPopulation::start(int task_id, ThreadPool *pool) noexcept(false) {

    // Move task to STARTED state
    DatabaseManager db_manager(DATABASE_NAME);
    TaskModel task_model(&db_manager);
    task_model.updateTaskStateById(task_id, Task::STARTED);

    auto *operations = new ConcurrentOperationQueue;

    pool->enqueue([operations] {
        run_compute_thread(operations);
    });

    pool->enqueue([task_id, operations] {
        run_populate_thread(task_id, operations);
    });

    return task_id;
}

/**
 * Awaiting for implementation
 */
void FlyCloudPopulation::stop() {
    throw FireflyException(HtmlStatusCode::NOT_IMPLEMENTED, "Stop action not yet implemented");
}

/**
 * Collect operations from database. We only collect the operations from the last time we collect.
 * @param task_id the id of the task we're collecting.
 * @param client_last_op index of the last operation that we performed.
 * @return operations performed from the last collect.
 */
std::vector<Operation> FlyCloudPopulation::collect(int task_id, int client_last_op) {
    DatabaseManager db_manager(DATABASE_NAME);
    OperationModel operation_model(&db_manager);
    return operation_model.getOperationsSince(task_id, client_last_op);
}

void FlyCloudPopulation::run_compute_thread(ConcurrentOperationQueue *operationQueue) {
    for (int i = 0; i < 10; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
        operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
        operationQueue->enqueue(Operation(OperationType::DELETE, cv::Vec3f(i, i, i)));
        operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
    }
    operationQueue->enqueue(Operation::buildEndOperation());
}

void FlyCloudPopulation::run_populate_thread(int task_id, ConcurrentOperationQueue *queue) {
    std::cout
            << "Thread starts for the task id : " << task_id
            << std::endl;

    // Trying to get task from database
    DatabaseManager db_manager(DATABASE_NAME);
    TaskModel task_model(&db_manager);
    Point3DModel point_model(&db_manager);

    try {
        // Save all operations in base
        Operation operation = queue->dequeue();
        while (!operation.isEndOperation()) {
            point_model.insertOperation(operation, task_id);
            operation = queue->dequeue();
        }

        // Move task to FINISHED state
        task_model.updateTaskStateById(task_id, Task::FINISHED);

    } catch (DatabaseException e) {
        throw FireflyException(HtmlStatusCode::BAD_REQUEST, e.what());
    }

    std::cout
            << "Thread have finished the work for the task of id : " << task_id
            << std::endl;
}

std::vector<Operation>
FlyCloudPopulation::computeOperationsFromPoints(const std::vector<Point3DBean> &points, int last_operation) {
    std::vector<Operation> operations;
    for (auto it = points.begin(); it < points.end(); it++) {
        Operation operation = computeOperationFromPoint(*it, last_operation);
        if (!operation.isNoneOperation() && !operation.isEndOperation()) {
            operations.push_back(operation);
        }

    }
    return operations;
}

/**
 * TODO: remake it using TDD and move it to a common place
 * @param point
 * @param last_operation
 * @return
 */
Operation FlyCloudPopulation::computeOperationFromPoint(const Point3DBean &point, int last_operation) {
    std::vector<int> op_indices = point.getOperationsIds();
    int point_last_op = op_indices.back();
    if (point_last_op <= last_operation) {
        return Operation::buildNoneOperation();
    }
    unsigned long long int i1 = op_indices.size() - 1;
    int i2 = 0;
    for (unsigned int i = 0; i < op_indices.size(); i++) {
        if (op_indices[i] <= last_operation)
            i2 = i;
        else
            break;
    }

    if ((i1 - i2) % 2 == 0 && i2 % 2 == 0) {
        return Operation(OperationType::ADD, point.getValue());
    }
    if ((i1 + i2) % 2 == 1 && i2 % 2 == 1) {
        return Operation(OperationType::DELETE, point.getValue());
    }

    return Operation::buildNoneOperation();
}
}
}