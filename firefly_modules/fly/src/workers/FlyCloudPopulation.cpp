// Copyright 2017 <CÃ©lian Garcia>

#include <fly_module/workers/FlyCloudPopulation.hpp>

namespace firefly {
namespace fly_module {

FlyCloudPopulation::FlyCloudPopulation(const std::string &host, int16_t port, const std::string &database,
                                       const std::string &user, const std::string &password) :
        host(host), port(port), database(database), user(user), password(password) {}

/**
 * - Initiate database connection;
 * - Initiate the cloud model with database manager;
 * - Insert cloud entry in the database;
 * - Run compute thread which put entries in queue;
 * - Run populate thread which move entries from queue to database.
 * @param pool
 * @return id generated by the database.
 */
int FlyCloudPopulation::start(int task_id, ThreadPool *pool, ProcessingType type) noexcept(false) {
    // Move task to STARTED state
    auto db_manager = new DatabaseManager(this->host, this->port, this->database, this->user, this->password);
    auto task_model = new TaskModel(db_manager);
    task_model->updateTaskStateById(task_id, Task::STARTED);
    delete task_model;
    delete db_manager;

    auto *operations = new ConcurrentOperationQueue;
    pool->enqueue([this, operations, type] {
        this->run_compute_thread(operations, type);
    });

    pool->enqueue([this, task_id, operations] {
        this->run_populate_thread(task_id, operations);
    });

    return task_id;
}

/**
 * Awaiting for implementation
 */
void FlyCloudPopulation::stop() {
    throw FireflyException(HtmlStatusCode::NOT_IMPLEMENTED, "Stop action not yet implemented");
}

/**
 * Data Producer : <br>
 * Produce all 3D points for consumer.
 * @param queue Channel where we write operations we create. Red by consumer.
 */
void FlyCloudPopulation::run_compute_thread(ConcurrentOperationQueue *queue, ProcessingType type) {
    fly::CloudFiller filler;
    filler.register_observer([queue](float x, float y, float z) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        queue->enqueue({OperationType::ADD, {"fpoint3d", {x, y, z}}});
    });

    if (type.getAliases()[0] == "P3D") {
        filler.random_filling(20, -10, 10);
    } else if (type.getAliases()[0] == "P3Dr") {
        filler.random_filling(20, -10, 10);
    } else if (type.getAliases()[0] == "P3Dd") {
        filler.diamond_filling(5, 4, 5, 4, 3, {0, 0, 0});
    }
    queue->endQueue();
}

/**
 * Data Consumer: <br>
 * Consumes all data given by producer storing them in the database.
 * @param task_id Still necessary to know where to store operations in database.
 * @param queue Channel where we read operations to save in database. Written by producer.
 */
void FlyCloudPopulation::run_populate_thread(int task_id, ConcurrentOperationQueue *queue) {
    std::cout << "Thread starts for the task id : " << task_id << std::endl;

    // Initiate database manager
    auto db_manager = new DatabaseManager(this->host, this->port, this->database, this->user, this->password);

    // Save progressively all operations in base
    auto operation_model = new OperationModel(db_manager);

    while (!queue->isEmptyAndEnded()) {
        Operation operation = queue->dequeue();
        operation_model->insertOperation(operation, task_id);
    }
    delete operation_model;

    // When operations are done, we move task to FINISHED state
    auto task_model = new TaskModel(db_manager);
    task_model->updateTaskStateById(task_id, Task::FINISHED);
    delete task_model;

    delete db_manager;
    std::cout << "Thread have finished the work for the task of id : " << task_id << std::endl;
}

}  // namespace fly_module
}  // namespace firefly
