// Copyright 2017 <Célian Garcia>

#include "firefly/modules/fly/workers/FlyCloudPopulation.hpp"

namespace firefly {
    namespace module_fly {
        const std::vector<ProcessActionType> FlyCloudPopulation::VALID_ACTION_TYPES = {
                ProcessActionType::START,
                ProcessActionType::STOP,
                ProcessActionType::COLLECT
        };
        const std::string FlyCloudPopulation::DATABASE_NAME = "fcloudpopulation";

        /**
         * - Initiate database connection;
         * - Initiate the cloud model with database manager;
         * - Insert cloud entry in the database;
         * - Run compute thread which put entries in queue;
         * - Run populate thread which move entries from queue to database.
         * @param pool
         * @return id generated by the database.
         */
        int FlyCloudPopulation::start(ThreadPool* pool) {

            DatabaseManager db_manager(DATABASE_NAME);
            Cloud3DModel cloud_model(&db_manager);
            int cloud_id = cloud_model.insertCloud(Cloud3DBean());

            ConcurrentOperationQueue *operations = new ConcurrentOperationQueue;

            pool->enqueue([operations] {
                run_compute_thread(operations);
            });

            pool->enqueue([cloud_id, operations] {
                run_populate_thread(cloud_id, operations);
            });

            return cloud_id;
        }

        /**
         * Awaiting for implementation
         */
        void FlyCloudPopulation::stop() {
            throw FireflyException(HtmlStatusCode::NOT_IMPLEMENTED, "Stop action not yet implemented");
        }

        /**
         * Collect operations from database. We only collect the operations from the last time we collect.
         * @param cloud_id the id of the cloud we're collecting.
         * @param client_last_op index of the last operation that we performed.
         * @return operations performed from the last collect.
         */
        std::vector<Operation> FlyCloudPopulation::collect(int cloud_id, int client_last_op) {
            DatabaseManager db_manager(DATABASE_NAME);
            Point3DModel point_model(&db_manager);
            std::vector<Point3DBean> points = point_model.getPointListByCloudId(cloud_id);
            std::vector<Operation> operations;

            // TODO(Célian): refactor this ugly code and unit test it oh yeah
            //////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(auto it=points.begin() ; it < points.end(); it++) {
                std::vector<int> op_indices = it->getOperationsIds();
                int point_last_op = op_indices.back();
                if (point_last_op <= client_last_op) {
                    break;
                }
                unsigned long long int i1 = op_indices.size() - 1;
                int i2 = 0;
                for (unsigned int i = 0; i < op_indices.size(); i++) {
                    if (op_indices[i] <= client_last_op)
                        i2 = i;
                    else
                        break;
                }

                if ((i1 - i2) % 2 == 0 && i2 % 2 == 0) {
                    operations.push_back(Operation(OperationType::ADD, it->getValue()));
                }
                // if ((i1 + i2) % 2 == 1 && i2 % 2 == 1) {
                //     operations.push_back(Operation(OperationType::DELETE, point.getValue()));
                // }
            }
            //////////////////////////////////////////////////////////////////////////////////////////////////////////


            return operations;
        }

        void FlyCloudPopulation::run_compute_thread(ConcurrentOperationQueue *operationQueue) {
            for (int i = 0; i < 10; ++i) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::REMOVE, cv::Vec3f(i, i, i)));
                operationQueue->enqueue(Operation(OperationType::ADD, cv::Vec3f(i, i, i)));
            }
            operationQueue->enqueue(Operation::buildEndOperation());
        }

        void FlyCloudPopulation::run_populate_thread(int cloud_id, ConcurrentOperationQueue* queue) {
            std::cout
                    << "Thread starts for the cloud id : " << cloud_id
                    << std::endl;

            // Initialize connection, cloud model, and point model
            DatabaseManager db_manager(DATABASE_NAME);
            Cloud3DModel cloud_model(&db_manager);
            Point3DModel point_model(&db_manager);
            Cloud3DBean cloud = cloud_model.getCloudById(cloud_id);

            // Update the cloud state to populating
            cloud_model.updateCloudState(&cloud, Cloud3DBean::POPULATING_STATE);

            Operation operation = queue->dequeue();
            while(!operation.isEndOperation()) {
                point_model.insertOperation(operation, cloud_id);
                operation = queue->dequeue();
            }

            cloud_model.updateCloudState(&cloud, Cloud3DBean::FINISHED_STATE);

            std::cout
                    << "Thread have finished the work for the cloud_id : " << cloud_id
                    << std::endl;
        }
    }
}